<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Symbolic Expressions and Constraint Solving &#8212; bisa  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Machine State - memory, registers, and so on" href="states.html" />
    <link rel="prev" title="Loading a Binary" href="loading.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="symbolic-expressions-and-constraint-solving">
<h1>Symbolic Expressions and Constraint Solving<a class="headerlink" href="#symbolic-expressions-and-constraint-solving" title="Link to this heading">¶</a></h1>
<p>bisa’s power comes not from it being an emulator, but from being able to execute
with what we call <em>symbolic variables</em>. Instead of saying that a variable has a
<em>concrete</em> numerical value, we can say that it holds a <em>symbol</em>, effectively
just a name. Then, performing arithmetic operations with that variable will
yield a tree of operations (termed an <em>abstract syntax tree</em> or <em>AST</em>, from
compiler theory). ASTs can be translated into constraints for an <em>SMT solver</em>,
like z3, in order to ask questions like <em>“given the output of this sequence of
operations, what must the input have been?”</em> Here, you’ll learn how to use bisa
to answer this.</p>
<section id="working-with-bitvectors">
<h2>Working with Bitvectors<a class="headerlink" href="#working-with-bitvectors" title="Link to this heading">¶</a></h2>
<p>Let’s get a dummy project and state so we can start playing with numbers.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">bisa</span><span class="o">,</span><span class="w"> </span><span class="nn">monkeyhex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proj</span> <span class="o">=</span> <span class="n">bisa</span><span class="o">.</span><span class="n">Project</span><span class="p">(</span><span class="s1">&#39;/bin/true&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">entry_state</span><span class="p">()</span>
</pre></div>
</div>
<p>A bitvector is just a sequence of bits, interpreted with the semantics of a
bounded integer for arithmetic. Let’s make a few.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 64-bit bitvectors with concrete values 1 and 100</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">one</span> <span class="o">=</span> <span class="n">claripy</span><span class="o">.</span><span class="n">BVV</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">one</span>
 <span class="o">&lt;</span><span class="n">BV64</span> <span class="mh">0x1</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">one_hundred</span> <span class="o">=</span><span class="n">claripy</span><span class="o">.</span><span class="n">BVV</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">one_hundred</span>
 <span class="o">&lt;</span><span class="n">BV64</span> <span class="mh">0x64</span><span class="o">&gt;</span>

<span class="c1"># create a 27-bit bitvector with concrete value 9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">weird_nine</span> <span class="o">=</span> <span class="n">claripy</span><span class="o">.</span><span class="n">BVV</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">27</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">weird_nine</span>
<span class="o">&lt;</span><span class="n">BV27</span> <span class="mh">0x9</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>As you can see, you can have any sequence of bits and call them a bitvector. You
can do math with them too:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">one</span> <span class="o">+</span> <span class="n">one_hundred</span>
<span class="go">&lt;BV64 0x65&gt;</span>

<span class="go"># You can provide normal Python integers and they will be coerced to the</span>
<span class="go">appropriate type: &gt;&gt;&gt; one_hundred + 0x100 &lt;BV64 0x164&gt;</span>

<span class="go"># The semantics of normal wrapping arithmetic apply</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">one_hundred</span> <span class="o">-</span> <span class="n">one</span><span class="o">*</span><span class="mi">200</span>
<span class="go">&lt;BV64 0xffffffffffffff9c&gt;</span>
</pre></div>
</div>
<p>You <em>cannot</em> say <code class="docutils literal notranslate"><span class="pre">one</span> <span class="pre">+</span> <span class="pre">weird_nine</span></code>, though. It is a type error to perform an
operation on bitvectors of differing lengths. You can, however, extend
<code class="docutils literal notranslate"><span class="pre">weird_nine</span></code> so it has an appropriate number of bits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weird_nine</span><span class="o">.</span><span class="n">zero_extend</span><span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">27</span><span class="p">)</span>
<span class="go">&lt;BV64 0x9&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">one</span> <span class="o">+</span> <span class="n">weird_nine</span><span class="o">.</span><span class="n">zero_extend</span><span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">27</span><span class="p">)</span>
<span class="go">&lt;BV64 0xa&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">zero_extend</span></code> will pad the bitvector on the left with the given number of zero
bits. You can also use <code class="docutils literal notranslate"><span class="pre">sign_extend</span></code> to pad with a duplicate of the highest
bit, preserving the value of the bitvector under two’s complement signed integer
semantics.</p>
<p>Now, let’s introduce some symbols into the mix.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a bitvector symbol named &quot;x&quot; of length 64 bits</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">claripy</span><span class="o">.</span><span class="n">BVS</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="o">&lt;</span><span class="n">BV64</span> <span class="n">x_9_64</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">claripy</span><span class="o">.</span><span class="n">BVS</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span>
<span class="o">&lt;</span><span class="n">BV64</span> <span class="n">y_10_64</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are now <em>symbolic variables</em>, which are kind of like the variables you learned to work with in 7th grade algebra.
Notice that the name you provided has been mangled by appending an incrementing counter and
You can do as much arithmetic as you want with them, but you won’t get a number back, you’ll get an AST instead.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="n">one</span>
<span class="go">&lt;BV64 x_9_64 + 0x1&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">one</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="go">&lt;BV64 (x_9_64 + 0x1) / 0x2&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
<span class="go">&lt;BV64 x_9_64 - y_10_64&gt;</span>
</pre></div>
</div>
<p>Technically <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> and even <code class="docutils literal notranslate"><span class="pre">one</span></code> are also ASTs - any bitvector is a
tree of operations, even if that tree is only one layer deep. To understand
this, let’s learn how to process ASTs.</p>
<p>Each AST has a <code class="docutils literal notranslate"><span class="pre">.op</span></code> and a <code class="docutils literal notranslate"><span class="pre">.args</span></code>. The op is a string naming the operation
being performed, and the args are the values the operation takes as input.
Unless the op is <code class="docutils literal notranslate"><span class="pre">BVV</span></code> or <code class="docutils literal notranslate"><span class="pre">BVS</span></code> (or a few others…), the args are all other
ASTs, the tree eventually terminating with BVVs or BVSs.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span>
<span class="go">&lt;BV64 (x_9_64 + 0x1) / (y_10_64 + 0x2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">op</span>
<span class="go">&#39;__floordiv__&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">args</span>
<span class="go">(&lt;BV64 x_9_64 + 0x1&gt;, &lt;BV64 y_10_64 + 0x2&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">op</span>
<span class="go">&#39;__add__&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span>
<span class="go">(&lt;BV64 x_9_64&gt;, &lt;BV64 0x1&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">op</span>
<span class="go">&#39;BVV&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span>
<span class="go">(1, 64)</span>
</pre></div>
</div>
<p>From here on out, we will use the word “bitvector” to refer to any AST whose
topmost operation produces a bitvector. There can be other data types
represented through ASTs, including floating point numbers and, as we’re about
to see, booleans.</p>
</section>
<section id="symbolic-constraints">
<h2>Symbolic Constraints<a class="headerlink" href="#symbolic-constraints" title="Link to this heading">¶</a></h2>
<p>Performing comparison operations between any two similarly-typed ASTs will yield
another AST - not a bitvector, but now a symbolic boolean.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">&lt;Bool x_9_64 == 0x1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="n">one</span>
<span class="go">&lt;Bool x_9_64 == 0x1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span>
<span class="go">&lt;Bool x_9_64 &gt; 0x2&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">one_hundred</span> <span class="o">+</span> <span class="mi">5</span>
<span class="go">&lt;Bool (x_9_64 + y_10_64) == 0x69&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">one_hundred</span> <span class="o">&gt;</span> <span class="mi">5</span>
<span class="go">&lt;Bool True&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">one_hundred</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">5</span>
<span class="go">&lt;Bool False&gt;</span>
</pre></div>
</div>
<p>One tidbit you can see from this is that the comparisons are unsigned by
default. The -5 in the last example is coerced to <code class="docutils literal notranslate"><span class="pre">&lt;BV64</span> <span class="pre">0xfffffffffffffffb&gt;</span></code>,
which is definitely not less than one hundred. If you want the comparison to be
signed, you can say <code class="docutils literal notranslate"><span class="pre">one_hundred.SGT(-5)</span></code> (that’s “signed greater-than”). A
full list of operations can be found at the end of this chapter.</p>
<p>This snippet also illustrates an important point about working with bisa - you
should never directly use a comparison between variables in the condition for an
if- or while-statement, since the answer might not have a concrete truth value.
Even if there is a concrete truth value, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">one</span> <span class="pre">&gt;</span> <span class="pre">one_hundred</span></code> will raise an
exception. Instead, you should use <code class="docutils literal notranslate"><span class="pre">solver.is_true</span></code> and <code class="docutils literal notranslate"><span class="pre">solver.is_false</span></code>,
which test for concrete truthyness/falsiness without performing a constraint
solve.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">yes</span> <span class="o">=</span> <span class="n">one</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">no</span> <span class="o">=</span> <span class="n">one</span> <span class="o">==</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maybe</span> <span class="o">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">is_true</span><span class="p">(</span><span class="n">yes</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">is_false</span><span class="p">(</span><span class="n">yes</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">is_true</span><span class="p">(</span><span class="n">no</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">is_false</span><span class="p">(</span><span class="n">no</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">is_true</span><span class="p">(</span><span class="n">maybe</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">is_false</span><span class="p">(</span><span class="n">maybe</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</section>
<section id="constraint-solving">
<h2>Constraint Solving<a class="headerlink" href="#constraint-solving" title="Link to this heading">¶</a></h2>
<p>You can treat any symbolic boolean as an assertion about the valid values of a
symbolic variable by adding it as a <em>constraint</em> to the state. You can then
query for a valid value of a symbolic variable by asking for an evaluation of a
symbolic expression.</p>
<p>An example will probably be more clear than an explanation here:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">10</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>By adding these constraints to the state, we’ve forced the constraint solver to
consider them as assertions that must be satisfied about any values it returns.
If you run this code, you might get a different value for x, but that value will
definitely be greater than 3 (since y must be greater than 2 and x must be
greater than y) and less than 10. Furthermore, if you then say
<code class="docutils literal notranslate"><span class="pre">state.solver.eval(y)</span></code>, you’ll get a value of y which is consistent with the
value of x that you got. If you don’t add any constraints between two queries,
the results will be consistent with each other.</p>
<p>From here, it’s easy to see how to do the task we proposed at the beginning of
the chapter - finding the input that produced a given output.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># get a fresh state without constraints</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">state</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">entry_state</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">input</span> <span class="o">=</span> <span class="n">claripy</span><span class="o">.</span><span class="n">BVS</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">operation</span> <span class="o">=</span> <span class="p">(((</span><span class="nb">input</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">input</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="mi">200</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">operation</span> <span class="o">==</span> <span class="n">output</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="mh">0x3333333333333381</span>
</pre></div>
</div>
<p>Note that, again, this solution only works because of the bitvector semantics.
If we were operating over the domain of integers, there would be no solutions!</p>
<p>If we add conflicting or contradictory constraints, such that there are no
values that can be assigned to the variables such that the constraints are
satisfied, the state becomes <em>unsatisfiable</em>, or unsat, and queries against it
will raise an exception. You can check the satisfiability of a state with
<code class="docutils literal notranslate"><span class="pre">state.satisfiable()</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">input</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">satisfiable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>You can also evaluate more complex expressions, not just single variables.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># fresh state</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">state</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">entry_state</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="mi">6</span>
</pre></div>
</div>
<p>From this we can see that <code class="docutils literal notranslate"><span class="pre">eval</span></code> is a general purpose method to convert any
bitvector into a Python primitive while respecting the integrity of the state.
This is why we use <code class="docutils literal notranslate"><span class="pre">eval</span></code> to convert from concrete bitvectors to Python ints,
too!</p>
<p>Also note that the x and y variables can be used in this new state despite
having been created using an old state. Variables are not tied to any one state,
and can exist freely.</p>
</section>
<section id="floating-point-numbers">
<h2>Floating point numbers<a class="headerlink" href="#floating-point-numbers" title="Link to this heading">¶</a></h2>
<p>z3 has support for the theory of IEEE754 floating point numbers, and so bisa can
use them as well. The main difference is that instead of a width, a floating
point number has a <em>sort</em>. You can create floating point symbols and values with
<code class="docutils literal notranslate"><span class="pre">FPV</span></code> and <code class="docutils literal notranslate"><span class="pre">FPS</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># fresh state</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">state</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">entry_state</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">claripy</span><span class="o">.</span><span class="n">FPV</span><span class="p">(</span><span class="mf">3.2</span><span class="p">,</span> <span class="n">claripy</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">FSORT_DOUBLE</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="o">&lt;</span><span class="n">FP64</span> <span class="n">FPV</span><span class="p">(</span><span class="mf">3.2</span><span class="p">,</span> <span class="n">DOUBLE</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">claripy</span><span class="o">.</span><span class="n">FPS</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">claripy</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">FSORT_DOUBLE</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="o">&lt;</span><span class="n">FP64</span> <span class="n">FPS</span><span class="p">(</span><span class="s1">&#39;FP_b_0_64&#39;</span><span class="p">,</span> <span class="n">DOUBLE</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="o">&lt;</span><span class="n">FP64</span> <span class="n">fpAdd</span><span class="p">(</span><span class="s1">&#39;RNE&#39;</span><span class="p">,</span> <span class="n">FPV</span><span class="p">(</span><span class="mf">3.2</span><span class="p">,</span> <span class="n">DOUBLE</span><span class="p">),</span> <span class="n">FPS</span><span class="p">(</span><span class="s1">&#39;FP_b_0_64&#39;</span><span class="p">,</span> <span class="n">DOUBLE</span><span class="p">))</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="mf">4.4</span>
<span class="o">&lt;</span><span class="n">FP64</span> <span class="n">FPV</span><span class="p">(</span><span class="mf">7.6000000000000005</span><span class="p">,</span> <span class="n">DOUBLE</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">0</span>
<span class="o">&lt;</span><span class="n">Bool</span> <span class="n">fpLT</span><span class="p">(</span><span class="n">fpAdd</span><span class="p">(</span><span class="s1">&#39;RNE&#39;</span><span class="p">,</span> <span class="n">FPS</span><span class="p">(</span><span class="s1">&#39;FP_b_0_64&#39;</span><span class="p">,</span> <span class="n">DOUBLE</span><span class="p">),</span> <span class="n">FPV</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">DOUBLE</span><span class="p">)),</span> <span class="n">FPV</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">DOUBLE</span><span class="p">))</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>So there’s a bit to unpack here - for starters the pretty-printing isn’t as
smart about floating point numbers. But past that, most operations actually have
a third parameter, implicitly added when you use the binary operators - the
rounding mode. The IEEE754 spec supports multiple rounding modes
(round-to-nearest, round-to-zero, round-to-positive, etc), so z3 has to support
them. If you want to specify the rounding mode for an operation, use the fp
operation explicitly (<code class="docutils literal notranslate"><span class="pre">claripy.fpAdd</span></code> for example) with a rounding mode (one of
<code class="docutils literal notranslate"><span class="pre">claripy.fp.RM_*</span></code>) as the first argument.</p>
<p>Constraints and solving work in the same way, but with <code class="docutils literal notranslate"><span class="pre">eval</span></code> returning a floating point number:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">-2.4999999999999996</span>
</pre></div>
</div>
<p>This is nice, but sometimes we need to be able to work directly with the
representation of the float as a bitvector. You can interpret bitvectors as
floats and vice versa, with the methods <code class="docutils literal notranslate"><span class="pre">raw_to_bv</span></code> and <code class="docutils literal notranslate"><span class="pre">raw_to_fp</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">raw_to_bv</span><span class="p">()</span>
<span class="go">&lt;BV64 0x400999999999999a&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">raw_to_bv</span><span class="p">()</span>
<span class="go">&lt;BV64 fpToIEEEBV(FPS(&#39;FP_b_0_64&#39;, DOUBLE))&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">claripy</span><span class="o">.</span><span class="n">BVV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">raw_to_fp</span><span class="p">()</span>
<span class="go">&lt;FP64 FPV(0.0, DOUBLE)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">claripy</span><span class="o">.</span><span class="n">BVS</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">raw_to_fp</span><span class="p">()</span>
<span class="go">&lt;FP64 fpToFP(x_1_64, DOUBLE)&gt;</span>
</pre></div>
</div>
<p>These conversions preserve the bit-pattern, as if you casted a float pointer to
an int pointer or vice versa. However, if you want to preserve the value as
closely as possible, as if you casted a float to an int (or vice versa), you can
use a different set of methods, <code class="docutils literal notranslate"><span class="pre">val_to_fp</span></code> and <code class="docutils literal notranslate"><span class="pre">val_to_bv</span></code>. These methods
must take the size or sort of the target value as a parameter, due to the
floating-point nature of floats.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&lt;FP64 FPV(3.2, DOUBLE)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">val_to_bv</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">&lt;BV12 0x3&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">val_to_bv</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">val_to_fp</span><span class="p">(</span><span class="n">claripy</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">FSORT_FLOAT</span><span class="p">)</span>
<span class="go">&lt;FP32 FPV(3.0, FLOAT)&gt;</span>
</pre></div>
</div>
<p>These methods can also take a <code class="docutils literal notranslate"><span class="pre">signed</span></code> parameter, designating the signedness of the source or target bitvector.</p>
</section>
<section id="more-solving-methods">
<h2>More Solving Methods<a class="headerlink" href="#more-solving-methods" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">eval</span></code> will give you one possible solution to an expression, but what if you want several?
What if you want to ensure that the solution is unique?
The solver provides you with several methods for common solving patterns:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solver.eval(expression)</span></code> will give you one possible solution to the given
expression.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver.eval_one(expression)</span></code> will give you the solution to the given
expression, or throw an error if more than one solution is possible.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver.eval_upto(expression,</span> <span class="pre">n)</span></code> will give you up to n solutions to the
given expression, returning fewer than n if fewer than n are possible.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver.eval_atleast(expression,</span> <span class="pre">n)</span></code> will give you n solutions to the given
expression, throwing an error if fewer than n are possible.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver.eval_exact(expression,</span> <span class="pre">n)</span></code> will give you n solutions to the given
expression, throwing an error if fewer or more than are possible.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver.min(expression)</span></code> will give you the minimum possible solution to the
given expression.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver.max(expression)</span></code> will give you the maximum possible solution to the
given expression.</p></li>
</ul>
<p>Additionally, all of these methods can take the following keyword arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">extra_constraints</span></code> can be passed as a tuple of constraints. These
constraints will be taken into account for this evaluation, but will not be
added to the state.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cast_to</span></code> can be passed a data type to cast the result to. Currently, this
can only be <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">bytes</span></code>, which will cause the method to return the
corresponding representation of the underlying data. For example,
<code class="docutils literal notranslate"><span class="pre">state.solver.eval(claripy.BVV(0x41424344,</span> <span class="pre">32),</span> <span class="pre">cast_to=bytes)</span></code> will
return <code class="docutils literal notranslate"><span class="pre">b'ABCD'</span></code>.</p></li>
</ul>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>That was a lot!! After reading this, you should be able to create and manipulate
bitvectors, booleans, and floating point values to form trees of operations, and
then query the constraint solver attached to a state for possible solutions
under a set of constraints. Hopefully by this point you understand the power of
using ASTs to represent computations, and the power of a constraint solver.</p>
<p><a class="reference external" href="ListofClaripyOperations">In the appendix</a>, you can find a reference for
all the additional operations you can apply to ASTs, in case you ever need a
quick table to look at.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">bisa</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started/index.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core Concepts</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="toplevel.html">Core Concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="loading.html">Loading a Binary</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Symbolic Expressions and Constraint Solving</a></li>
<li class="toctree-l2"><a class="reference internal" href="states.html">Machine State - memory, registers, and so on</a></li>
<li class="toctree-l2"><a class="reference internal" href="pathgroups.html">Simulation Managers</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation.html">Simulation  and Instrumentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="analyses.html">Analyses</a></li>
<li class="toctree-l2"><a class="reference internal" href="symbolic.html">Symbolic Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="be_creative.html">A final word of advice</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../analyses/index.html">Build-in Analyses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced-topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extending-bisa/index.html">Extending bisa</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">bisa examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Core Concepts</a><ul>
      <li>Previous: <a href="loading.html" title="previous chapter">Loading a Binary</a></li>
      <li>Next: <a href="states.html" title="next chapter">Machine State - memory, registers, and so on</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, The bisa Project contributors.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/core-concepts/solver.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>