<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Symbolic Execution &#8212; bisa  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="A final word of advice" href="be_creative.html" />
    <link rel="prev" title="Analyses" href="analyses.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="symbolic-execution">
<h1>Symbolic Execution<a class="headerlink" href="#symbolic-execution" title="Link to this heading">¶</a></h1>
<p>Symbolic execution is a program analysis technique used to explore multiple
execution paths of a program simultaneously. Unlike normal execution, which
runs the program with specific inputs, symbolic execution treats inputs as
symbolic variables rather than concrete values. This means the execution
can represent a wide range of inputs with symbolic expressions. Symbolic
execution allows, at a time in emulation, to determine for a branch all
conditions necessary to take a branch or not. Every variable is represented
as a symbolic value, and each branch as a constraint. Thus, symbolic execution
allows us to see which conditions allow the program to go from point A to
point B by resolving these constraints. The execution paths are then analyzed
by solving constraints generated by these symbolic expressions, allowing the
discovery of bugs and vulnerabilities that might be missed in standard testing.</p>
<section id="example">
<h2>Example:<a class="headerlink" href="#example" title="Link to this heading">¶</a></h2>
<p>Consider the following simple program :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">check_value</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Greater&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Lesser or Equal&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In normal execution, if <code class="docutils literal notranslate"><span class="pre">x</span></code> is set to 5, the program will follow the path
where <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">10</span></code> and return “Lesser or Equal”. In symbolic execution, <code class="docutils literal notranslate"><span class="pre">x</span></code>
is treated as a symbolic variable, <code class="docutils literal notranslate"><span class="pre">X</span></code>. The execution engine explores both
paths:</p>
<blockquote>
<div><ul class="simple">
<li><p>Path 1: <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&gt;</span> <span class="pre">10</span></code> leading to the result “Greater”</p></li>
<li><p>Path 2: <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&lt;=</span> <span class="pre">10</span></code> leading to the result “Lesser or Equal”</p></li>
</ul>
</div></blockquote>
<p>Constraints for both paths are generated and solved to understand all possible
behaviors of the program.</p>
<p>In software verification, it helps ensure that the code behaves as expected
across all possible inputs and states. For security analysis, symbolic execution
can uncover vulnerabilities such as input validation errors, which could be
exploited by attackers. Additionally, in automated testing, it aids in
generating comprehensive test cases that cover edge cases and rare execution
paths, enhancing the robustness and security of software systems. Overall,
symbolic execution provides a powerful means to rigorously analyze and improve
software and firmware reliability.</p>
</section>
<section id="basic-execution">
<h2>Basic Execution<a class="headerlink" href="#basic-execution" title="Link to this heading">¶</a></h2>
<p>Now let’s see an example use case of symbolic execution with bisa. Consider the following example code,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">helloWorld</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span><span class="w"> </span><span class="nf">firstCall</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">100</span><span class="p">)</span>
<span class="w">        </span><span class="n">HelloWorld</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">firstCall</span></code> function will accept a 32-bit number as an input and will call
<code class="docutils literal notranslate"><span class="pre">helloWorld</span></code> function if the number is between 50 and 100.</p>
<p>You can perform a symbolic execution to find a correct and valid input to reach
the final <code class="docutils literal notranslate"><span class="pre">helloWorld</span></code> function call with bisa using the following sample code.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">bisa</span><span class="o">,</span><span class="w"> </span><span class="nn">claripy</span>
<span class="c1"># Load the binary</span>
<span class="n">project</span> <span class="o">=</span> <span class="n">bisa</span><span class="o">.</span><span class="n">Project</span><span class="p">(</span><span class="s1">&#39;./3func&#39;</span><span class="p">,</span> <span class="n">auto_load_libs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Define the address of the firstCall function</span>
<span class="n">firstCall_addr</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">main_object</span><span class="o">.</span><span class="n">get_symbol</span><span class="p">(</span><span class="s2">&quot;firstCall&quot;</span><span class="p">)</span>

<span class="c1"># Define the address of the helloWorld function</span>
<span class="n">helloWorld_addr</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">main_object</span><span class="o">.</span><span class="n">get_symbol</span><span class="p">(</span><span class="s2">&quot;helloWorld&quot;</span><span class="p">)</span>
<span class="c1"># Create a symbolic variable for the firstCall arg</span>
<span class="n">input_arg</span> <span class="o">=</span> <span class="n">claripy</span><span class="o">.</span><span class="n">BVS</span><span class="p">(</span><span class="s1">&#39;input_arg&#39;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="c1"># Create a blank state at the address of the firstCall function</span>
<span class="n">init_state</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">blank_state</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="n">firstCall_addr</span><span class="o">.</span><span class="n">rebased_addr</span><span class="p">)</span>

<span class="c1"># Assuming the calling convention passes the argument in a register</span>
<span class="c1"># (e.g., x86 uses edi for the argument)</span>
<span class="n">init_state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">edi</span> <span class="o">=</span> <span class="n">input_arg</span>

<span class="c1"># Create a simulation manager</span>
<span class="n">simgr</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">simulation_manager</span><span class="p">(</span><span class="n">init_state</span><span class="p">)</span>

<span class="c1"># Explore the binary, looking for the address of helloWorld</span>
<span class="n">simgr</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">find</span><span class="o">=</span><span class="n">helloWorld_addr</span><span class="o">.</span><span class="n">rebased_addr</span><span class="p">)</span>

<span class="c1"># Check if we found a state that reached the target</span>
<span class="k">if</span> <span class="n">simgr</span><span class="o">.</span><span class="n">found</span><span class="p">:</span>
    <span class="n">input_value</span> <span class="o">=</span> <span class="n">simgr</span><span class="o">.</span><span class="n">found</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">input_arg</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value of input_arg that reaches HelloWorld: </span><span class="si">{</span><span class="n">input_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Get the constraints for reaching the helloWorld function</span>
    <span class="n">constraints</span> <span class="o">=</span> <span class="n">simgr</span><span class="o">.</span><span class="n">found</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">constraints</span>
    <span class="c1"># Create a solver with the constraints</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">claripy</span><span class="o">.</span><span class="n">Solver</span><span class="p">()</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
    <span class="n">min_val</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">input_arg</span><span class="p">)</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">input_arg</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Function arg: min = </span><span class="si">{</span><span class="n">min_val</span><span class="si">}</span><span class="s2">, max = </span><span class="si">{</span><span class="n">max_val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Did not find a state that reaches HelloWorld.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>It will produce the output like the below with a valid example function arg that can reach the
function <code class="docutils literal notranslate"><span class="pre">helloWorld</span></code> that you can use as a test case.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>Value<span class="w"> </span>of<span class="w"> </span>input_arg<span class="w"> </span>that<span class="w"> </span>reaches<span class="w"> </span>HelloWorld:<span class="w"> </span><span class="m">71</span>
Function<span class="w"> </span>arg:<span class="w"> </span><span class="nv">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">51</span>,<span class="w"> </span><span class="nv">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">99</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">bisa</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started/index.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core Concepts</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="toplevel.html">Core Concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="loading.html">Loading a Binary</a></li>
<li class="toctree-l2"><a class="reference internal" href="solver.html">Symbolic Expressions and Constraint Solving</a></li>
<li class="toctree-l2"><a class="reference internal" href="states.html">Machine State - memory, registers, and so on</a></li>
<li class="toctree-l2"><a class="reference internal" href="pathgroups.html">Simulation Managers</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation.html">Simulation  and Instrumentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="analyses.html">Analyses</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Symbolic Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="be_creative.html">A final word of advice</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../analyses/index.html">Build-in Analyses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced-topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extending-bisa/index.html">Extending bisa</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">bisa examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Core Concepts</a><ul>
      <li>Previous: <a href="analyses.html" title="previous chapter">Analyses</a></li>
      <li>Next: <a href="be_creative.html" title="next chapter">A final word of advice</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, The bisa Project contributors.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/core-concepts/symbolic.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>